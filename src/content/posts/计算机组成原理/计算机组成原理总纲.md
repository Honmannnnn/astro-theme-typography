---
title: 《计算机组成原理》总纲📌
pubDate: 2025-06-24
categories: ['Principles of Computer Organization']
description: '《计算机组成原理》复习重点'
slug: Key points of review
---

# 计算机组成原理总纲

## 第一章 概论

### 填空题 + 简答题

1. `MIPS`是一个`指令速度`单位

2. 电子计算机的发展是以`设计cpu所使用的电子元器件的更新`作为依据的

3. 冯诺依曼的特点（存储程序并且按地址顺序执行）：

   - 硬件由运算器、存储器、控制器、输入和输出设备五大基本部件组成
   - 计算机内部采用二进制来表示指令和数据
   - 将编好的程序和原始数据事先存入存储器中 然后再启动计算机工作 这就是存储程序的基本含义

4. 根据程序和数据的存放形式 存储器设计思想可以分为`冯诺依曼结构(主存储器)`和`哈佛结构(单片机、数字信号处理系统)` 两者结合起来可以提高主存储器的利用率、提高程序执行的效率、缩短执行时钟周期

5. 哈佛结构 速度快 但是结构复杂（指令和数据是分开的） 不可便面总线拥挤

6. 微机系统组成图（分软硬件、分主机和外设）：

   具体分解如下：

   - **主机（Host）**：

     - CPU (中央处理器)：

       - **运算器**：负责执行算术运算和逻辑运算。
       - **控制器**：负责解释指令，控制计算机各部件协调工作。

     - 存储器：

       - **主存（主存储器/内存）**：与CPU直接交互，用于存储当前正在运行的程序和数据。
       - **辅存（辅助存储器/外存储器）**：用于长期存储大量数据和程序（如硬盘、SSD等）。

   - **I/O设备（输入/输出设备）**：

     - **输入设备**：用于将外部信息（如用户指令、数据）输入到计算机。
     - **输出设备**：用于将计算机处理结果输出给用户或外部设备。

7. 低级语言有`汇编语言`、`机器语言`

## 第二章 数据的机器层次表示

### 计算题

1. `机器数`和`真值`来回换算

2. 负数的原码、反码、补码之间的转换关系为：在原码的基础上，符号位不变，数值位取反得到反码；在反码的基础上，末位加1（逢二进一）得到补码

3. 符号位为0（原码、反码、补码都一样）

4. 补码变移码 值同浮反

5. 机器数的定点表示：

   一个32位的二进制数，从左到右，其结构分解如下：

   | 部分  | 位范围  | 位数 | 含义            |
   | :---- | :------ | :--- | :-------------- |
   | **S** | 31      | 1    | 符号位          |
   | **E** | 30 ~ 23 | 8    | 指数位          |
   | **M** | 22 ~ 0  | 23   | 尾数位/小数部分 |

   - **S (符号位)**：第31位。$S=0$ 表示正数，$S=1$ 表示负数。
   - **E (指数位)**：第30位至第23位。这是一个**偏移指数 (Biased Exponent)**。
   - **M (尾数位/小数部分)**：第22位至第0位。表示浮点数的小数部分，隐含一个整数位 $1$。

   **2. 转换公式**

   对于规格化的IEEE 754单精度浮点数，其十进制值可由以下公式计算：

   $$\text{Value} = (-1)^S \times (1.\text{M}) \times 2^{(E - \text{Bias})}$$

   其中：

   - $S$：符号位的值 (0 或 1)。
   - $1.\text{M}$：规格化尾数，$1$ 是隐含的整数部分，$\text{M}$ 是23位尾数代表的二进制小数。
   - $E$：8位指数位转换成的十进制整数值。
   - $\text{Bias}$：对于IEEE 754单精度浮点数，$\text{Bias} = 127$。

6. 非数值数据的表示

## 第三章 指令系统

1. 数据寻址的的方式

   具体来说：

   **5 种常见的基本寻址方式：**

   这通常指的是最核心、最常见的5种操作数寻址方式，它们是其他复杂寻址方式的基础：

   1. **立即寻址（Immediate Addressing）**：操作数直接包含在指令中。
      - **特点：** 取操作数速度最快，无需访问内存。
      - **例子：** `ADD R1, #5` (将立即数5加到R1中)
   2. **直接寻址（Direct Addressing）**：指令中直接给出操作数的有效地址。
      - **特点：** 需要访问一次内存才能取到操作数。
      - **例子：** `LOAD R1, [1000H]` (将内存地址1000H处的内容加载到R1中)
   3. **寄存器寻址（Register Addressing）**：操作数存放在CPU内部的寄存器中，指令中给出寄存器的编号。
      - **特点：** 取操作数速度最快，无需访问内存。
      - **例子：** `ADD R1, R2` (将R2的内容加到R1中)
   4. **寄存器间接寻址（Register Indirect Addressing）**：指令中给出的是一个寄存器编号，该寄存器中存放的是操作数的有效地址。
      - **特点：** 灵活，需要访问一次内存。
      - **例子：** `LOAD R1, [R2]` (将R2中存放的地址所指向的内存内容加载到R1中)
   5. **变址寻址（Indexed Addressing）**：有效地址由指令中给定的地址（或基地址）与一个变址寄存器（Index Register）的内容相加得到。
      - **特点：** 方便处理数组、字符串等连续存储的数据结构。
      - **例子：** `LOAD R1, 100[R2]` (将地址100加上R2的内容作为有效地址，加载该地址处的内容到R1)

   **3 种常用/特殊寻址方式：**

   这通常指在特定应用中非常有用或具有特定性质的寻址方式：

   1. **相对寻址（Relative Addressing）**：有效地址由指令地址（Program Counter, PC）与指令中给定的偏移量相加得到。
      - **特点：** 常用于程序跳转指令，可以实现程序浮动（重定位），与程序在内存中的绝对位置无关。
      - **例子：** `JMP +100` (跳转到当前指令地址向后100个单元的地址)
   2. **基址寻址（Base Addressing）**：有效地址由基址寄存器（Base Register）的内容与指令中给定的位移量相加得到。
      - **特点：** 同样用于程序重定位，常用于多道程序环境，各程序段共享同一个基址寄存器。
      - **例子：** `LOAD R1, [Base_Reg + Offset]` (将基址寄存器内容加上偏移量作为有效地址，加载该地址处的内容到R1)
   3. **堆栈寻址（Stack Addressing）**：操作数的地址隐式地由堆栈指针（Stack Pointer, SP）给出。操作通常是压栈（Push）和出栈（Pop）。
      - **特点：** 支持子程序调用和返回，以及表达式求值。
      - **例子：** `PUSH R1` (将R1的内容压入堆栈)

   **1 种特殊寻址方式：**

   这个“1”可能指代以下某一种，具体取决于教材的侧重：

   - **隐含寻址（Implied/Implicit Addressing）**：指令中不显式包含操作数的地址，操作数的位置是隐含的或由指令本身决定的（例如，累加器指令）。
     - **特点：** 缩短指令长度，简化指令格式，但灵活性较低。
     - **例子：** `CLA` (Clear Accumulator，清除累加器，累加器AC是隐含的操作数)
   - **间接寻址（Indirect Addressing）**：指令中给出的地址不是操作数的有效地址，而是存放操作数有效地址的地址。可能需要多次内存访问。
     - **特点：** 可以扩大寻址范围。
     - **例子：** `LOAD R1, @1000H` (内存地址1000H处存放的是另一个地址，真实操作数在这个地址)
     - _注意：_ 寄存器间接寻址是间接寻址的一种特殊情况。

## 第四章 数值的机器运算

### 计算题

1. 定点加减运算（用补码来加减运算：补码可以把减法变成加法 为了简化计算机的设计 一定要会求$ [-y]\_补$）

2. 定点乘法运算

3. 规格化浮点 只掌握表示（加减运算的步骤：对阶、尾数加减、规格化、舍入、判断溢出）

   例题：已知$ X = 0.11011，Y = -0.10101 $ 计算出$X+Y$ 并支出结果是否溢出

   我们假设 X 和 Y 都是定点纯小数，并且使用补码进行运算。

   **1. 确定机器字长和补码表示**

   假设使用8位二进制（1位符号位 + 7位数值位）来表示定点纯小数。 最高位是符号位，小数点在符号位和数值位之间。

   - **X = 0.11011** X 是正数。正数的原码、反码、补码都相同。 X原=0.11011002 (补齐到7位小数位) X补=0.11011002

   - **Y = -0.10101** Y 是负数。 Y原=1.10101002 (符号位为1，数值部分是0.1010100)

     负数原码转换为补码的步骤： a. 原码符号位不变 (1) b. 数值部分按位取反 (1010100 -> 0101011) c. 末位加1 (0101011 + 1 = 0101100) 所以，Y补=1.01011002

   **2. 进行补码加法运算**

   X补=0.11011002 Y补=1.01011002

   0.1101100 +1.0101100

   进位： 111 1 结果： 0.0011000

   - 从右往左相加： 0+0=0 0+0=0 1+1=0 (进1) 1+1=0 (进1) + 1 = 1 (进1) 0+0=0 (进1) + 1 = 1 (进1) 1+1=0 (进1) + 1 = 1 (进1) 1+0=1 (进1) + 1 = 0 (进1) 符号位：0+1=1 (进1) + 1 = 0 (进1) 最左边溢出的进位（符号位的进位）是1，被舍弃。

   所以，X+Y 的结果补码是 0.00110002

   **3. 转换结果补码为真值**

   结果补码是 0.00110002。 由于符号位是0，表示这是一个正数。正数的补码就是其原码，也就是其真值。

   所以，结果的真值是 +0.00110002。 将其转换为十进制： 0×20+0×2−1+0×2−2+1×2−3+1×2−4+0×2−5+0×2−6+0×2−7 =0.125+0.0625=0.1875

   **4. 判断是否溢出**

   对于定点纯小数，其表示范围通常是 (−1,1)。 或者说，如果最高位（符号位）的进位和次高位（数值位最高位）的进位不同，则发生溢出。

   ## 在我们的计算中：

   $X_补=0.1101100 $ 、$ Y\_补=1.0101100$

   符号位加法进位（符号位左边的进位）：1 次高位加法进位（数值位最高位左边的进位）：1

   由于**符号位的进位 (1) 和数值位最高位的进位 (1) 相同**，因此**没有发生溢出**。

   或者，直观判断： 正数 + 负数，结果落在范围内是正常的。 0.1101110≈0.828125 −0.1010110≈−0.65625 0.828125−0.65625=0.171875 我们的计算结果是 0.1875，非常接近，且在 (−1,1) 范围内，所以没有溢出。

   **总结：**

   - X补=0.11011002
   - Y补=1.01011002
   - X补+Y补=0.00110002
   - 结果的真值是 +0.00110002=+0.187510。
   - **没有发生溢出。**
   - 补充：符号位01 正溢出 、 符号位10 负溢出

## 第五章 存储系统和结构

### 简答题

1. 存储系统和结构分哪几层？

   - cache
   - 主存
   - 外存

2. DRAM（主存刷新）和SRAM（cache 快小贵 触发器）的区别是什么？存储数据的原理分别是什么？

   **DRAM（动态随机存取存储器）与 SRAM（静态随机存取存储器）的区别**

   | 特点/维度    | DRAM（Dynamic RAM）                                            | SRAM（Static RAM）                                           |
   | ------------ | -------------------------------------------------------------- | ------------------------------------------------------------ |
   | **存储原理** | **电容**存储电荷                                               | **触发器（Flip-Flop）**存储数据                              |
   | **结构**     | 一个晶体管和一个电容                                           | 多个（通常6个）晶体管（或4个晶体管+2个电阻）                 |
   | **刷新需求** | **需要周期性刷新**（定期给电容充电，防止电荷泄漏导致数据丢失） | **不需要刷新**（只要有电，数据就保持）                       |
   | **速度**     | 相对**慢**（因为需要刷新和充电时间）                           | 相对**快**（不需要刷新，直接访问触发器状态）                 |
   | **功耗**     | 相对**高**（因为需要频繁刷新）                                 | 相对**低**（稳态功耗低，但动态功耗可能高）                   |
   | **集成度**   | **高**（结构简单，单位面积存储容量大）                         | **低**（每个单元晶体管多，单位面积存储容量小）               |
   | **成本**     | **低**（制造成本低，是**主流内存**的选择）                     | **高**（制造成本高）                                         |
   | **应用**     | **主存储器（内存条）**、显存                                   | **高速缓存（Cache）**（CPU内部、L1/L2/L3 Cache）、路由器内存 |

3. 什么是cache？有什么作用？

   解决速度不匹配的问题

4. 命中率的概念是什么？

   **命中率的概念：**

   命中率是指在所有对某一存储层（例如Cache）的访问中，**成功在该层找到所需数据（即“命中”）的次数所占的比例**。

   用公式表示就是：

   命中率=总访问次数命中次数

   其中：

   - **命中次数（Hit Count）**：CPU（或其他请求方）在Cache中找到了所需数据的次数。
   - **总访问次数（Total Access Count）**：CPU（或其他请求方）尝试访问该存储层（例如Cache）的总次数。 总访问次数 = 命中次数 + 缺失次数（Miss Count）

5. EPROM 和 EEPROM 的区别

   ### 主要区别总结：

   | 特点/维度    | EPROM                                    | EEPROM                                       |
   | ------------ | ---------------------------------------- | -------------------------------------------- |
   | **擦除方式** | 紫外线擦除                               | 电信号擦除                                   |
   | **擦除范围** | 整片擦除                                 | 可字节擦除或块/页擦除                        |
   | **编程方式** | 高压电脉冲编程                           | 电脉冲编程                                   |
   | **封装特点** | 芯片顶部有透明石英窗，用于紫外线照射     | 标准封装，无透明窗                           |
   | **便捷性**   | 擦除不方便，需特殊设备，耗时             | 擦除方便，可在电路中完成，速度快             |
   | **应用场景** | 早期固件开发、少量生产、不需现场频繁修改 | 需频繁修改小量数据的非易失性存储，如配置信息 |

6. 字和位同时扩展 如何片选？（高位地址线编译）

   ### 字和位同时扩展中的片选机制（高位地址线译码）

   在计算机存储器设计中，为了从较小容量、较窄位宽的存储芯片构建出更大容量、更宽位宽的存储系统，需要同时进行**字扩展**（增加存储单元数量）和**位扩展**（增加每个存储单元的位数）。这两种扩展方式都需要精密的**片选（Chip Select, CS）**逻辑来确保在任何时刻只有目标芯片组被激活。

   当采用**高位地址线译码**进行片选时，意味着系统地址总线中的高位部分被专门用于选择不同的存储芯片或存储器组。

   **核心思想：**

   1. **位扩展：** 多个存储芯片的数据线并行连接，共同组成更宽的数据总线。这些芯片总是**同时被选中**，因为它们共同构成一个完整的字。
   2. **字扩展：** 不同的存储芯片或芯片组占据不同的地址空间。通过译码系统地址总线中的**高位地址线**，产生片选信号，确保只有特定地址范围内的芯片组被激活。

## 第六章 中央处理器

### 简答题 + 应用题

1. 寄存器有哪一些？（5+1）

   #### 5 种核心或功能寄存器

   这5种通常指的是CPU中用于执行指令周期的核心功能寄存器：

   1. **程序计数器（Program Counter, PC）**
      - **作用：** 存放下一条要执行的指令的地址。
      - **特点：** CPU在取指后会自动更新PC，使其指向下一条指令的地址。它是实现程序顺序执行的关键。
   2. **指令寄存器（Instruction Register, IR）**
      - **作用：** 存放当前正在执行或即将译码执行的指令。
      - **特点：** 从内存中取出的指令首先被送到IR，然后由控制器对IR中的指令进行译码。
   3. **存储器地址寄存器（Memory Address Register, MAR）**
      - **作用：** 存放CPU要访问的存储单元的地址。
      - **特点：** CPU在读写内存时，首先将要访问的地址送到MAR，然后由MAR连接到地址总线，用于寻址内存单元。
   4. **存储器数据寄存器（Memory Data Register, MDR）**
      - **作用：** 存放CPU从存储器中读取到的数据，或者CPU要写入存储器的数据。
      - **特点：** MDR连接到数据总线，是CPU与内存之间数据传输的桥梁。
   5. **累加器（Accumulator, AC）** / **通用寄存器（General Purpose Registers, GPRs）**
      - **作用：** 存放操作数或运算的中间结果。现代CPU中，累加器常被更灵活的通用寄存器组所取代。通用寄存器组可以用于存放数据、地址、中间结果等，是CPU进行各种操作的主要工作区。
      - **特点：** CPU访问速度最快，是ALU（算术逻辑单元）直接操作的对象。

   #### +1 种特殊或集合性寄存器

   这个“+1”通常指的是：

   1. 状态寄存器（Status Register）

      程序状态字寄存器（Program Status Word, PSW）

      - **作用：** 存放运算结果的各种状态信息（如进位C、零Z、溢出OV、负N等标志），以及CPU的当前工作状态（如中断允许、特权级等）。
      - **特点：** 这些标志位由ALU的运算结果自动设置，并可以被条件分支指令用来改变程序执行流程。它是实现条件判断和程序控制的关键。
